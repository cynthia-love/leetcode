# -*- coding: utf-8 -*-
# Author: Cynthia

"""
    第2章, 面向对象编程
"""

"""
    基本概念
    
    1. 类class的实例instance称为对象object
    2. 类定义了对象的实例变量instance variable, 又称数据成员data member
       还定义了对象的可执行方法methods, 又称成员函数member function
    3. 面向对象的设计目标
       健壮性robustness, 不光可以处理正确输入, 还可以处理各种异常情况(同一环境统一应用下)
       适应性adaptability, 可以适应各种外部环境的变化, 比如硬件, 平台, 时间发展(跨环境)
       重用性reusability, 同样的代码可以用在不用的应用中(同一环境下跨应用)
    4. 面向对象的设计原则(模块化-健壮性, 重用性; 抽象化; 封装-健壮性, 适应性)
       模块化: 比如一所房子的电力系统, 热力系统, 水力系统等不同的功能单元, 比如python中的模块, 就是
              一个关系比较密切的函数和类的集合, 比如math, os. 模块化可以提升健壮性, 因为不同的组件易于
              测试和调试, 且问题比较容易定位到相对独立的特定组件; 模块化还可以提升重用性, 比如很多地方都
              能引入math, os等模块. 
       抽象化: 即从一个复杂的系统中提炼出最基础的部分, Abstract Data Types, ADT, 它定义了数据存储的
              类型和支持的操作, 其更关心要做什么而不是怎么做, 一般对应到interface而不是class
              Python里没有interface, 而是使用一种称为Abstract Base Class, ABC, 的机制, 其性质
              和interface差不多, 不能被实例化, 且继承类必须实现其规定的所有方法, 其应用场景包括
              希望判断某个对象的类型或强制继承类必须实现某些方法(python里的抽象基类主要在abc和
              collections.abc里). 注意, 虽然python里有抽象基类机制, 但不建议用, 因为python的
              风格更偏向于鸭子机制, 只要"一直鸟走起来像鸭子, 游起来像鸭子, 叫起来像鸭子, 就可以称为鸭子."
              比如def f(m): print(m[0]), 不会强制规定m的类型, 只要m支持数字索引, 那就能打印m[0]
              
       封装:  软件系统的不同组件不应该显示其各自实现的内部细节, 只需要保持一致的公共接口即可, 比如排序
             方法, 内部用哪种排序随便, 只要最终达到排序效果就行. 封装可以增加健壮性和适应性, 因为它
             允许修改程序的内部实现细节而不影响其他部分, 从而更容易修复漏洞(不会牵一发动全身)和给
             组件中增加对更多场景的适应性. 按照惯例, 在python里, 以_开头的数据成员和成员函数被认为
             是非公开的, 外部不应该直接用, 另外, 自动生成文档时也会自动忽略这些非公开成员.
"""
"""
    5. 设计模式!!!重要!!!
    设计模式, 即一种解决问题的模板, 告诉你在什么情况下应该用怎样的解决方案, 怎么用, 包括一个名称, 一个
    语境, 如何应用, 以及产出是什么. 分为两大类, 算法设计模式和软件工程模式
    
    (1) 算法设计模式
    算法分析相关的: 最好、最坏、平均、摊销(最坏情况下的平均)
    算法结构相关的: 非递归、递归
    算法思想相关的: 暴力 减治 分治 回溯 分支限界 贪心 动态规划, 这7个算法思想一定牢牢掌握 
    
    (2) 软件工程设计模式
    创建型模式: 工厂, 抽象工厂, 单例, 建造者, 原型
    结构型模式: 适配器, 装饰器, 代理, 外观, 桥接, 组合, 享元
    行为型模式: 策略, 模板, 观察者, 访问者, 中介者, 迭代器, 责任链, 命令, 备忘录, 状态, 解释器
    
    下面一个一个解释设计模式
    
"""

"""算法设计模式"""
# 1.1.1 算法设计模式-算法分析-最好

# 1.1.2 算法设计模式-算法分析-最坏

# 1.1.3 算法设计模式-算法分析-平均

# 1.1.4 算法设计模式-算法分析-摊销

# 1.2.1 算法设计模式-算法结构-非递归

# 1.2.2 算法设计模式-算法结构-递归

# 1.3.1 算法设计模式-算法思想-暴力

# 1.3.2 算法设计模式-算法思想-减治

# 1.3.3 算法设计模式-算法思想-分治

# 1.3.4 算法设计模式-算法思想-回溯

# 1.3.5 算法设计模式-算法思想-分支限界

# 1.3.6 算法设计模式-算法思想-贪心

# 1.3.7 算法设计模式-算法思想-动态规划

"""软件工程设计模式"""
# 2.1.1 软件工程设计模式-创建型模式-工厂
# 2.1.2 软件工程设计模式-创建型模式-抽象工厂
# 2.1.3 软件工程设计模式-创建型模式-单例
# 2.1.4 软件工程设计模式-创建型模式-建造者
# 2.1.5 软件工程设计模式-创建型模式-原型

# 2.2.1 软件工程设计模式-结构型模式-适配器
# 2.2.2 软件工程设计模式-结构型模式-装饰器
# 2.2.3 软件工程设计模式-结构型模式-代理
# 2.2.4 软件工程设计模式-结构型模式-外观
# 2.2.5 软件工程设计模式-结构型模式-桥接
# 2.2.6 软件工程设计模式-结构型模式-组合
# 2.2.7 软件工程设计模式-结构型模式-享元

# 2.3.1 软件工程设计模式-行为型模式-策略
# 2.3.2 软件工程设计模式-行为型模式-模板
# 2.3.3 软件工程设计模式-行为型模式-观察者
# 2.3.4 软件工程设计模式-行为型模式-访问者
# 2.3.5 软件工程设计模式-行为型模式-中介者
# 2.3.6 软件工程设计模式-行为型模式-迭代器
# 2.3.7 软件工程设计模式-行为型模式-责任链
# 2.3.8 软件工程设计模式-行为型模式-命令
# 2.3.9 软件工程设计模式-行为型模式-备忘录
# 2.3.10 软件工程设计模式-行为型模式-状态
# 2.3.11 软件工程设计模式-行为型模式-解释器





