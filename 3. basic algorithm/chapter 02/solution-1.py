# -*- coding: utf-8 -*-
# Author: Cynthia

"""
    第2章, 面向对象编程
"""

"""
    基本概念
    
    1. 类class的实例instance称为对象object
    2. 类定义了对象的实例变量instance variable, 又称数据成员data member
       还定义了对象的可执行方法methods, 又称成员函数member function
    3. 面向对象的设计目标
       健壮性robustness, 不光可以处理正确输入, 还可以处理各种异常情况
       适应性adaptability, 可以适应各种外部环境的变化, 比如硬件, 平台, 时间发展
       重用性reusability, 同样的代码可以用在不用的应用中
    4. 面向对象的设计原则
       模块化: 比如一所房子的电力系统, 热力系统, 水力系统等不同的功能单元, 比如python中的模块, 就是
              一个关系比较密切的函数和类的集合, 比如math, os. 模块化可以提升健壮性, 因为不同的组件易于
              测试和调试, 且问题比较容易定位到相对独立的特定组件; 模块化还可以提升重用性, 比如很多地方都
              能引入math, os等模块. 
       抽象化: 即从一个复杂的系统中提炼出最基础的部分, Abstract Data Types, ADT, 它定义了数据存储的
              类型和支持的操作, 其更关心要做什么而不是怎么做, 一般对应到interface而不是class
              Python里没有interface, 而是使用一种称为Abstract Base Class, ABC, 的机制, 其性质
              和interface差不多, 不能被实例化, 且继承类必须实现其规定的所有方法, 其应用场景包括
              希望判断某个对象的类型或强制继承类必须实现某些方法(python里的抽象基类主要在abc和
              collections.abc里). 注意, 虽然python里有抽象基类机制, 但不建议用, 因为python的
              风格更偏向于鸭子机制, 只要"一直鸟走起来像鸭子, 游起来像鸭子, 叫起来像鸭子, 就可以称为鸭子."
              比如def f(m): print(m[0]), 不会强制规定m的类型, 只要m支持数字索引, 那就能打印m[0]
              
       封装:  软件系统的不同组件不应该显示其各自实现的内部细节, 只需要保持一致的公共接口即可, 比如排序
             方法, 内部用哪种排序随便, 只要最终达到排序效果就行. 封装可以增加健壮性和适应性, 因为它
             允许修改程序的内部实现细节而不影响其他部分, 从而更容易修复漏洞(不会牵一发动全身)和给
             组件中增加对更多场景的适应性. 按照惯例, 在python里, 以_开头的数据成员和成员函数被认为
             是非公开的, 外部不应该直接用, 另外, 自动生成文档时也会自动忽略这些非公开成员
"""

