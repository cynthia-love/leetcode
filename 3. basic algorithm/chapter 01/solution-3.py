# -*- coding: utf-8 -*-
# Author: Cynthia

"""
    运算符
    和值一起, 构成表达式
"""

# 逻辑运算符, 注意and和or会短路保护, 如果第一个值已经能决定最终结果就不往后算了
print(not 1, 8 or 9, 8 and 0)  # False, 8, 0, 我们发现后两个返回的并不是True/False

# 相等运算符, is和is not判断的是否是同一个对象, 而不仅仅是值是否相等
x = 1
y = 2
print(x is y, x is not y, x == y, x != y, [1, 2, 3] is [1, 2, 3], [1, 2] == [1, 2])
# False, True, False, True, False, True

# 比较运算符
print(1 < 8, 'abc' < 'abcd', 'abc' < 'abd')  # True, True, True

# 算数运算符; 有一个值是浮点则结果也是浮点; /特殊, 俩都是整数结果也是浮点
print(1+1, 1-1, 1*1, 1/1, 100 // 8, 100 % 8)
# 2, 0, 1, 1.0, 12(商), 4(余数)
# 特别地, //和%可以扩展到负数
print(-8 // 3, 8//(-3), -8 % 3, 8 % (-3), -8 // -3, -8 % -3)
# y = ax+b, 当x为正数, 0 <= b < x, 当x为负数, x < b <= 0; 即除数决定了余数的符号和大小范围
# 怎么记是个问题: 同号, 商正, 且往小了算, 比如-8/-3, 8/3, 商都是2, 余数自然就出来了
# 异号, 商负, 往大了算, 比如-8/3, 8/-3, 商都是-3, 余数自然也出来了
# 特别地, //和%可以扩展到小数, 同时为负数的话遵循上面的规律
print(1.1 // 0.3, 1.1 % 0.3)  # 3.0, 0.2

# 位运算符, 注意位运算符是针对补码算的!!!
# 取反
print(~0b1011)  # 注意0bxxxx这种写法是无符号的, 如果要赋值负数, 前面加负号
# 正数的补码就是源码, 负数的补码是除符号位所有位置取反再加1, 补码转源码是再算一遍补码的补码
# 这里怎么理解呢, 首先0b1011是正数11(负数就直接带负号了), 其补码还是0,1011(注意前面的符号位0)
# 取反, 变成1,0100, 然后转原码, 符号位不动, 其余位置取反加1, 变成1, 1011->1, 1100, 即-12
print(~-0b1011)
# 这里结果是10, 怎么理解呢, -0b1011是-11, 原码1, 1011, 补码1, 0100->1, 0101
# 取反, 0, 1010, 然后转原码, 因为符号位是正的, 所以原码等于补码, 0, 1010, 所以结果为正10
print(0b11 & 0b01, 0b11 | 0b01, 0b11 ^ 0b01, 0b01 << 1, 0b01 >> 1, int("-11", 2) >> 1)
# 1, 3, 2, 2, 0, 4; << 用0填充, >>用符号位填充
# -0b11, 原码1, 11, 补码1, 00, 右移1位, 1, 10, 转换成原码1, 01->1, 10, 即-2

# 序列运算符(list, tuple, str)
x = [8, 7, 6, 100, 200, 300]
print(x[0], x[1:2], x[3:1:-1], x+x, x*2, 3 in x, 3 not in x, x[-1], x[1:])
# -1表示倒数第一个元素; 切片是半开放的, 包含头部不包含尾部; 切片想包括头或尾时, 不能用0, -1, 要直接省略
# 切片的step为负数时, 注意前面两个数字要是倒叙的3:1, 不能是1:3
print("" in "abc")  # True, 用in判断元素是否存在时, 注意这种特殊情况, 任何字符串包含空字符穿
print([5, 6, 9] < [5, 7])  # True, 序列大于小于等于判断时, 按字典顺序, 一个一个往后比
print([5, 6] < [5, 6, 7])  # 如果在相同元素范围内能比出来最好, 如果比不出来, 谁长谁大

# 集合和字典运算符
# 集合
x = {1, 2, 3}
y = {1, 2, 3, 4, 5}
print(1 in x, 2 not in x, x == y, x < y, x | y, x & y, x ^ y, y - x)
# 集合里的>, < 比的不是大小, 而是表示子集/超集; | & ^不是表示按位操作, 而是并集, 交集, 对称差分
# x ^ y = y - x | x - y
# 字典
x = {1:2, 3:4}
y = {"1":2, "3":4}
print(x == y)  # 注意这里是False, 字典没有>, < 概念, 只有key-value完全一样才有相等的概念
print(y["1"], "3" in y)
y["4"] = 5
del y["1"]
print(y)

# 特殊的+=
x = 1
x += 3  # int是不可变, 这里并没有改变原int对象, 而是生成了一个新的int对象再赋给x

x = [1, 2, 3]
y = z = x
y += [4, 5]
z = z + [7, 8]
print(x)  # 这里x变成了[1, 2, 3, 4, 5], 却没有加上[7, 8]
# 说明 z += xxx在list这里行为并不完全与z = z + xxx相同

# 运算符优先级, 同一级别优先级高的比优先级低的先执行, 相同则从左向右执行
# 链接赋值, 注意是把最右边的直接赋值给多个标识符, 而不是一个一个往左赋值
x = y = 0
# 链接比较运算符
print(1 <= x+3 <= 100)




