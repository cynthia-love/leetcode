# -*- coding: utf-8 -*-

# Author: Cynthia

"""
    方法5, 大神的5行神仙解法, 学习一下
    以1000/3十进制为例, 和之前的方法先提前算出来最大位移位数相比, 此法不先算出来
    而是先计算当前, 然后一有机会就往大了窜

    1000, 3, 位移0->1000-3, 30, 1, 位移1

    997, 30, 位移1->997-30, 300, 1+10, 位移2

    697, 300, 位移2, 697-300, 3000, 11+100, 位移3

    397 < 3000, 397, 300, 位移2

    397, 300, 397-300, 3000, 111+100, 位移3

    97 < 3000, 97, 300, 位移2

    97 < 300, 97, 30, 位移1

    97, 30, 位移1, 97-30, 300, 211+10, 位移2

    37 < 300, 位移2, 30, 位移1
    37, 30, 位移1, 37-30, 300, 位移2


"""


class Solution:

    def divide(self, dividend: int, divisor: int) -> int:
        dd, dr, r, c = abs(dividend), abs(divisor), 0, 0

        # 首先思考循环终止条件, 1000/3, 3->30->300->3000
        # 3000的时候dd < dr了, 但是此时不能退出, 而是要往回找
        # 什么时候退, dd < 3的时候, 即位移为0的dd < dr
        # dd < dr and c <= 0

        while dd >= dr or c > 0:

            if dd >= dr:
                dd, dr, r, c = dd - dr, dr << 1, r + (1 << c), c + 1
            else:
                dr, c = dr >> 1, c - 1

        # 1 << 31 相当于 2**31
        return min([-r, r][dividend ^ divisor >= 0], (1 << 31) - 1)


s = Solution()
print(s.divide(100, 3))
